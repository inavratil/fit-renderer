//TessEval
layout(triangles, equal_spacing, cw) in;
in vec4 tcPosition[];
in vec2 tcCoord[];

uniform mat4 in_ModelViewMatrix;
uniform mat4 in_CutMatrix;

uniform vec2 near_far; // near and far plane for cm-cams
uniform float ZOOM;

#ifdef PARABOLA_CUT
uniform vec4 cut_params; //-- min/max values for cut (on x-axis)
#endif

out vec2 teCoord;
out vec4 tePosition;

void main()
{
    //vertex position from tessellator
    vec4 p0 = gl_TessCoord.x * tcPosition[0];
    vec4 p1 = gl_TessCoord.y * tcPosition[1];
    vec4 p2 = gl_TessCoord.z * tcPosition[2];
    tePosition = p0 + p1 + p2;
    //texture coordinate
    vec2 t0 = gl_TessCoord.x * tcCoord[0];
    vec2 t1 = gl_TessCoord.y * tcCoord[1];
    vec2 t2 = gl_TessCoord.z * tcCoord[2];
    teCoord = t0 + t1 + t2;
    
    //paraboloid projection
    vec4 vertexEyeSpace = in_ModelViewMatrix * tePosition;
    gl_ClipDistance[0] = -vertexEyeSpace.z;

    vertexEyeSpace = in_CutMatrix * vertexEyeSpace;
    
    float Length = length( vertexEyeSpace.xyz );
    vertexEyeSpace.z *= -1.0;
    vertexEyeSpace.xyz = normalize( vertexEyeSpace.xyz );

    vertexEyeSpace.z += 1.0;
    vertexEyeSpace.xy /= vertexEyeSpace.z;

#ifdef PARABOLA_CUT
    vertexEyeSpace.x = ((vertexEyeSpace.x - cut_params.x)/(cut_params.y - cut_params.x)) * 2.0 - 1.0;
    vertexEyeSpace.y = ((vertexEyeSpace.y - cut_params.z)/(cut_params.w - cut_params.z)) * 2.0 - 1.0;
#else
    vertexEyeSpace.xy /= ZOOM;   //zoom-in
#endif

    vertexEyeSpace.z = (Length - near_far.x)/(near_far.y  - near_far.x);
    vertexEyeSpace.w = 1.0; 

    tePosition = vertexEyeSpace;

    gl_Position = vertexEyeSpace;
}
