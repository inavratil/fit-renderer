//TessEval
layout(triangles, equal_spacing, cw) in;
in vec4 tcPosition[];
in vec2 tcCoord[];

uniform mat4 in_ModelViewMatrix;

uniform vec2 near_far; // near and far plane for cm-cams

out vec2 teCoord;
out vec4 tePosition;

uniform mat4 coeffsX;
uniform mat4 coeffsY;

const float SCREEN_X = 128.0;
const float SCREEN_Y = 128.0;

const int INSIDE = 0;	//0x0000;
const int TOP = 1;		//0x0001;
const int BOTTOM = 2;	//0x0010;
const int RIGHT = 4;	//0x0100;
const int LEFT = 8;		//0x1000;

int computeCode(vec2 _p, vec4 range)
{
        int ret;
 
        ret = INSIDE;       
 
        if (_p.x < range.x)           // to the left of clip window
                ret |= LEFT;
        else if (_p.x > range.y)      // to the right of clip window
                ret |= RIGHT;
        if (_p.y < range.z)           // below the clip window
                ret |= BOTTOM;
        else if (_p.y > range.w)      // above the clip window
                ret |= TOP;
 
        return ret;
}

void main()
{
    //vertex position from tessellator
    vec4 p0 = gl_TessCoord.x * tcPosition[0];
    vec4 p1 = gl_TessCoord.y * tcPosition[1];
    vec4 p2 = gl_TessCoord.z * tcPosition[2];
    tePosition = p0 + p1 + p2;
    //texture coordinate
    vec2 t0 = gl_TessCoord.x * tcCoord[0];
    vec2 t1 = gl_TessCoord.y * tcCoord[1];
    vec2 t2 = gl_TessCoord.z * tcCoord[2];
    teCoord = t0 + t1 + t2;
    
	//------------------------------------------------------------------------------------
    //paraboloid projection
    vec4 vertexEyeSpace = in_ModelViewMatrix * tePosition;
    gl_ClipDistance[0] = -vertexEyeSpace.z;
    
    float Length = length( vertexEyeSpace.xyz );
    vertexEyeSpace.z *= -1.0;
    vertexEyeSpace.xyz = normalize( vertexEyeSpace.xyz );

    vertexEyeSpace.z += 1.0;
    vertexEyeSpace.xy /= vertexEyeSpace.z;
    vertexEyeSpace.z = (Length - near_far.x)/(near_far.y  - near_far.x);
    vertexEyeSpace.w = 1.0; 

	tePosition = vertexEyeSpace;

	//------------------------------------------------------------------------------------
	// Polynomial warping

	vec4 range = vec4( 41.0, 83.0, 11.0, 41.0 );

	vec2 p = tePosition.xy;
	p = p*0.5 + 0.5;
	p = p * vec2( 128.0, 128.0 );

	int code = computeCode(p, range);

	float dx,dy;
	if ( code == INSIDE )
	{
		float new_x = (p.x - range.x)/(range.y - range.x) * (3.0 - 0.0) + 0.0;
		float new_y = (p.y - range.z)/(range.w - range.z) * (3.0 - 0.0) + 0.0;

		vec4 X = vec4( 1.0, new_x, pow(new_x, 2.0), pow(new_x,3.0) );
		vec4 Y = vec4( 1.0, new_y, pow(new_y, 2.0), pow(new_y,3.0) );
		
		vec4 temp = X * coeffsX;
		dx = dot(temp, Y) * 25.0/1024.0;
		temp = X * coeffsY;
		dy = dot(temp, Y) * 25.0/1024.0;
		//dx = dx * 2.0 - 1.0;
		//dy = dy * 2.0 - 1.0;

		vertexEyeSpace.x += dx;
		vertexEyeSpace.y += dy;
	}

    gl_Position = vertexEyeSpace;
}
